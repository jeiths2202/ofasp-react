{
  "program_name": "TEST_PROGRAM",
  "java_class_name": "TestProgram",
  "java_source": "package com.openasp.smed;\n\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\nimport com.openasp.common.JSONResponse;\nimport com.openasp.encoding.EncodingService;\nimport com.openasp.websocket.PositionSmedWebSocketService;\n\n/**\n * Generated Java class from COBOL program\n * Supports position-based SMED rendering with WebSocket communication\n * Auto-generated on 2025-07-31T15:28:49.371350\n */\n@Component\npublic class TestProgram {\n\n    private static final PositionField[] MAP_DEFINITION;\n    private PositionSmedWebSocketService webSocketService;\n    private EncodingService encodingService;\n    private Map<String, String> currentFieldData = new ConcurrentHashMap<>();\n\n    static {\n        MAP_DEFINITION = new PositionField[] {\n            new PositionField(1, 1, 20),\n            new PositionField(1, 23, 10),\n            new PositionField(1, 35, 15),\n            new PositionField(1, 52, 8),\n            new PositionField(1, 62, 20)\n        };\n    }\n\n    public void displayScreen-Data() {\n        try {\n            // Prepare field data array matching position order\n            String[] fieldData = new String[MAP_DEFINITION.length];\n            \n            // Set display field values\n            fieldData[0] = \"Test Screen\";\n            fieldData[1] = getCurrentFieldValue(\"INPUT-FIELD\");\n            fieldData[2] = getCurrentFieldValue(\"OUTPUT-FIELD\");\n            \n            // Convert to UTF-8 if needed\n            String[] utf8FieldData = convertToUtf8(fieldData);\n            \n            // Send position-based SMED display via WebSocket\n            Map<String, Object> displayData = new HashMap<>();\n            displayData.put(\"map_name\", \"SCREEN-DATA\");\n            displayData.put(\"map_data\", Arrays.asList(MAP_DEFINITION));\n            displayData.put(\"field_data\", Arrays.asList(utf8FieldData));\n            displayData.put(\"terminal_id\", getCurrentTerminalId());\n            displayData.put(\"encoding\", \"utf-8\");\n            displayData.put(\"timestamp\", new Date().toInstant().toString());\n            \n            webSocketService.sendPositionSmedDisplay(displayData);\n            \n            // Handle interactive processing if DESTINATION specified\n            // No interactive processing required\n            \n            logger.info(\"Display sent for SCREEN-DATA\");\n            \n        } catch (Exception e) {\n            logger.error(\"Error in display method: \" + e.getMessage(), e);\n            throw new RuntimeException(\"Display operation failed\", e);\n        }\n        \n    }\n\n    public Map<String, String> acceptUser-Input() {\n        try {\n            // Setup WebSocket listener for input events  \n            String mapName = \"USER-INPUT\";\n            \n            // Subscribe to position SMED updates\n            webSocketService.subscribeToPositionUpdates(mapName, (updateData) -> {\n                handlePositionUpdate(updateData);\n            });\n            \n            // Setup key event handler\n            String[] terminationKeysArray = [\"ENTER\", \"F3\", \"F12\"];\n            webSocketService.subscribeToKeyEvents(mapName, (keyEvent) -> {\n                return handleKeyEvent(keyEvent, terminationKeysArray);\n            });\n            \n            // Wait for user input or termination key\n            CompletableFuture<Map<String, String>> inputFuture = new CompletableFuture<>();\n            \n            // Setup termination key handling\n            setupTerminationKeys(terminationKeysArray, inputFuture);\n            \n            // Block until input is complete\n            Map<String, String> inputData = inputFuture.get(300, TimeUnit.SECONDS); // 5 minute timeout\n            \n            // Convert from UTF-8 to SJIS if needed\n            Map<String, String> sjisInputData = convertFromUtf8(inputData);\n            \n            // Update current field data\n            currentFieldData.putAll(sjisInputData);\n            \n            logger.info(\"Accept completed for USER-INPUT\");\n            return sjisInputData;\n            \n        } catch (TimeoutException e) {\n            logger.warn(\"Accept operation timed out for USER-INPUT\");\n            throw new RuntimeException(\"Input timeout\", e);\n        } catch (Exception e) {\n            logger.error(\"Error in accept method: \" + e.getMessage(), e);\n            throw new RuntimeException(\"Accept operation failed\", e);\n        }\n        \n    }\n\n    public String[] convertToUtf8(String[] sjisData) {\n            try {\n                String[] utf8Data = new String[sjisData.length];\n                for (int i = 0; i < sjisData.length; i++) {\n                    if (sjisData[i] != null) {\n                        utf8Data[i] = encodingService.convertSjisToUtf8(sjisData[i]);\n                    } else {\n                        utf8Data[i] = \"\";\n                    }\n                }\n                return utf8Data;\n            } catch (Exception e) {\n                logger.error(\"UTF-8 conversion error: \" + e.getMessage(), e);\n                return sjisData; // Return original data on error\n            }\n            \n    }\n\n    public Map<String, String> convertFromUtf8(Map<String, String> utf8Data) {\n            try {\n                Map<String, String> sjisData = new HashMap<>();\n                for (Map.Entry<String, String> entry : utf8Data.entrySet()) {\n                    String convertedValue = encodingService.convertUtf8ToSjis(entry.getValue());\n                    sjisData.put(entry.getKey(), convertedValue);\n                }\n                return sjisData;\n            } catch (Exception e) {\n                logger.error(\"SJIS conversion error: \" + e.getMessage(), e);\n                return utf8Data; // Return original data on error\n            }\n            \n    }\n\n    // Helper methods\n    private String getCurrentTerminalId() {\n        // Get current terminal ID from session or context\n        return \"TERM001\"; // Default terminal ID\n    }\n    \n    private String getCurrentFieldValue(String fieldName) {\n        return currentFieldData.getOrDefault(fieldName, \"\");\n    }\n    \n    private boolean isInteractiveProcessingActive() {\n        // Check if interactive processing should continue\n        return webSocketService.isInteractiveMode(getCurrentTerminalId());\n    }\n    \n    private void processWebSocketEvents() {\n        // Process incoming WebSocket events\n        webSocketService.processIncomingEvents(getCurrentTerminalId());\n    }\n    \n    private void handlePositionUpdate(Map<String, Object> updateData) {\n        // Handle position-based field updates from WebSocket\n        @SuppressWarnings(\"unchecked\")\n        List<Map<String, Object>> updates = (List<Map<String, Object>>) updateData.get(\"updates\");\n        \n        for (Map<String, Object> update : updates) {\n            int row = (Integer) update.get(\"row\");\n            int col = (Integer) update.get(\"col\");\n            String value = (String) update.get(\"value\");\n            \n            // Find field by position and update value\n            updateFieldByPosition(row, col, value);\n        }\n    }\n    \n    private boolean handleKeyEvent(Map<String, Object> keyEvent, String[] terminationKeys) {\n        String key = (String) keyEvent.get(\"key\");\n        \n        // Check if it's a termination key\n        for (String termKey : terminationKeys) {\n            if (termKey.equals(key)) {\n                return true; // Terminate input\n            }\n        }\n        \n        return false; // Continue input\n    }\n    \n    private void setupTerminationKeys(String[] terminationKeys, \n                                    CompletableFuture<Map<String, String>> inputFuture) {\n        // Setup handlers for termination keys\n        for (String key : terminationKeys) {\n            webSocketService.onKeyEvent(getCurrentTerminalId(), key, () -> {\n                inputFuture.complete(getCurrentFieldData());\n            });\n        }\n    }\n    \n    private Map<String, String> getCurrentFieldData() {\n        return new HashMap<>(currentFieldData);\n    }\n    \n    private void updateFieldByPosition(int row, int col, String value) {\n        // Find field by position in MAP_DEFINITION\n        for (int i = 0; i < MAP_DEFINITION.length; i++) {\n            PositionField field = MAP_DEFINITION[i];\n            if (field.row == row && field.col == col) {\n                currentFieldData.put(\"field_\" + i, value);\n                break;\n            }\n        }\n    }\n}\n\n/**\n * Position field definition for SMED mapping\n */\nclass PositionField {\n    public final int row;\n    public final int col;\n    public final int length;\n    \n    public PositionField(int row, int col, int length) {\n        this.row = row;\n        this.col = col; \n        this.length = length;\n    }\n}\n",
  "map_json": "[\n  {\n    \"row\": 1,\n    \"col\": 1,\n    \"length\": 20\n  },\n  {\n    \"row\": 1,\n    \"col\": 23,\n    \"length\": 10\n  },\n  {\n    \"row\": 1,\n    \"col\": 35,\n    \"length\": 15\n  },\n  {\n    \"row\": 1,\n    \"col\": 52,\n    \"length\": 8\n  },\n  {\n    \"row\": 1,\n    \"col\": 62,\n    \"length\": 20\n  }\n]",
  "sample_data_json": "[\n  \"Sample1\",\n  \"Sample2\",\n  \"Sample3\",\n  \"\",\n  \"\"\n]",
  "position_fields_count": 5,
  "display_files_count": 1,
  "accept_files_count": 1,
  "conversion_timestamp": "2025-07-31T15:28:49.371417"
}