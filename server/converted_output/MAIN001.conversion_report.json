{
  "program_name": "MAIN001",
  "java_class_name": "Main001",
  "java_source": "package com.openasp.smed;\n\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\nimport com.openasp.common.JSONResponse;\nimport com.openasp.encoding.EncodingService;\nimport com.openasp.websocket.PositionSmedWebSocketService;\n\n/**\n * Generated Java class from COBOL program\n * Supports position-based SMED rendering with WebSocket communication\n * Auto-generated on 2025-08-01T08:18:17.732665\n */\n@Component\npublic class Main001 {\n\n    private static final PositionField[] MAP_DEFINITION;\n    private PositionSmedWebSocketService webSocketService;\n    private EncodingService encodingService;\n    private Map<String, String> currentFieldData = new ConcurrentHashMap<>();\n\n    static {\n        MAP_DEFINITION = new PositionField[] {\n            new PositionField(1, 1, 30),\n            new PositionField(1, 33, 20),\n            new PositionField(1, 55, 20),\n            new PositionField(2, 1, 20),\n            new PositionField(2, 23, 20),\n            new PositionField(2, 45, 20),\n            new PositionField(2, 67, 50)\n        };\n    }\n\n    public void displayWs-Message-Line() {\n        try {\n            // Prepare field data array matching position order\n            String[] fieldData = new String[MAP_DEFINITION.length];\n            \n            // Set display field values\n            \n            \n            // Convert to UTF-8 if needed\n            String[] utf8FieldData = convertToUtf8(fieldData);\n            \n            // Send position-based SMED display via WebSocket\n            Map<String, Object> displayData = new HashMap<>();\n            displayData.put(\"map_name\", \"WS-MESSAGE-LINE\");\n            displayData.put(\"map_data\", Arrays.asList(MAP_DEFINITION));\n            displayData.put(\"field_data\", Arrays.asList(utf8FieldData));\n            displayData.put(\"terminal_id\", getCurrentTerminalId());\n            displayData.put(\"encoding\", \"utf-8\");\n            displayData.put(\"timestamp\", new Date().toInstant().toString());\n            \n            webSocketService.sendPositionSmedDisplay(displayData);\n            \n            // Handle interactive processing if DESTINATION specified\n            // No interactive processing required\n            \n            logger.info(\"Display sent for WS-MESSAGE-LINE\");\n            \n        } catch (Exception e) {\n            logger.error(\"Error in display method: \" + e.getMessage(), e);\n            throw new RuntimeException(\"Display operation failed\", e);\n        }\n        \n    }\n\n    public void displayWs-Screen-Fields() {\n        try {\n            // Prepare field data array matching position order\n            String[] fieldData = new String[MAP_DEFINITION.length];\n            \n            // Set display field values\n            fieldData[0] = \"=== 管理メニュー ===\";\n            fieldData[1] = \"１）参照\";\n            fieldData[2] = \"２）追加\";\n            fieldData[3] = \"３）更新\";\n            fieldData[4] = \"４）削除\";\n            fieldData[5] = \"選択：\";\n            fieldData[6] = getCurrentFieldValue(\"WS-MESSAGE-LINE\");\n            \n            // Convert to UTF-8 if needed\n            String[] utf8FieldData = convertToUtf8(fieldData);\n            \n            // Send position-based SMED display via WebSocket\n            Map<String, Object> displayData = new HashMap<>();\n            displayData.put(\"map_name\", \"WS-SCREEN-FIELDS\");\n            displayData.put(\"map_data\", Arrays.asList(MAP_DEFINITION));\n            displayData.put(\"field_data\", Arrays.asList(utf8FieldData));\n            displayData.put(\"terminal_id\", getCurrentTerminalId());\n            displayData.put(\"encoding\", \"utf-8\");\n            displayData.put(\"timestamp\", new Date().toInstant().toString());\n            \n            webSocketService.sendPositionSmedDisplay(displayData);\n            \n            // Handle interactive processing if DESTINATION specified\n            \n            if (\"DISPLAY\".equals(\"DISPLAY\")) {\n                handleInteractiveProcess();\n            }\n            \n            \n            logger.info(\"Display sent for WS-SCREEN-FIELDS\");\n            \n        } catch (Exception e) {\n            logger.error(\"Error in display method: \" + e.getMessage(), e);\n            throw new RuntimeException(\"Display operation failed\", e);\n        }\n        \n    }\n\n    public void displayWs-Message-Line() {\n        try {\n            // Prepare field data array matching position order\n            String[] fieldData = new String[MAP_DEFINITION.length];\n            \n            // Set display field values\n            \n            \n            // Convert to UTF-8 if needed\n            String[] utf8FieldData = convertToUtf8(fieldData);\n            \n            // Send position-based SMED display via WebSocket\n            Map<String, Object> displayData = new HashMap<>();\n            displayData.put(\"map_name\", \"WS-MESSAGE-LINE\");\n            displayData.put(\"map_data\", Arrays.asList(MAP_DEFINITION));\n            displayData.put(\"field_data\", Arrays.asList(utf8FieldData));\n            displayData.put(\"terminal_id\", getCurrentTerminalId());\n            displayData.put(\"encoding\", \"utf-8\");\n            displayData.put(\"timestamp\", new Date().toInstant().toString());\n            \n            webSocketService.sendPositionSmedDisplay(displayData);\n            \n            // Handle interactive processing if DESTINATION specified\n            // No interactive processing required\n            \n            logger.info(\"Display sent for WS-MESSAGE-LINE\");\n            \n        } catch (Exception e) {\n            logger.error(\"Error in display method: \" + e.getMessage(), e);\n            throw new RuntimeException(\"Display operation failed\", e);\n        }\n        \n    }\n\n    public void displayWs-Status-Message() {\n        try {\n            // Prepare field data array matching position order\n            String[] fieldData = new String[MAP_DEFINITION.length];\n            \n            // Set display field values\n            \n            \n            // Convert to UTF-8 if needed\n            String[] utf8FieldData = convertToUtf8(fieldData);\n            \n            // Send position-based SMED display via WebSocket\n            Map<String, Object> displayData = new HashMap<>();\n            displayData.put(\"map_name\", \"WS-STATUS-MESSAGE\");\n            displayData.put(\"map_data\", Arrays.asList(MAP_DEFINITION));\n            displayData.put(\"field_data\", Arrays.asList(utf8FieldData));\n            displayData.put(\"terminal_id\", getCurrentTerminalId());\n            displayData.put(\"encoding\", \"utf-8\");\n            displayData.put(\"timestamp\", new Date().toInstant().toString());\n            \n            webSocketService.sendPositionSmedDisplay(displayData);\n            \n            // Handle interactive processing if DESTINATION specified\n            // No interactive processing required\n            \n            logger.info(\"Display sent for WS-STATUS-MESSAGE\");\n            \n        } catch (Exception e) {\n            logger.error(\"Error in display method: \" + e.getMessage(), e);\n            throw new RuntimeException(\"Display operation failed\", e);\n        }\n        \n    }\n\n    public Map<String, String> acceptWs-User-Selection() {\n        try {\n            // Setup WebSocket listener for input events  \n            String mapName = \"WS-USER-SELECTION\";\n            \n            // Subscribe to position SMED updates\n            webSocketService.subscribeToPositionUpdates(mapName, (updateData) -> {\n                handlePositionUpdate(updateData);\n            });\n            \n            // Setup key event handler\n            String[] terminationKeysArray = [\"ENTER\", \"F3\", \"F12\"];\n            webSocketService.subscribeToKeyEvents(mapName, (keyEvent) -> {\n                return handleKeyEvent(keyEvent, terminationKeysArray);\n            });\n            \n            // Wait for user input or termination key\n            CompletableFuture<Map<String, String>> inputFuture = new CompletableFuture<>();\n            \n            // Setup termination key handling\n            setupTerminationKeys(terminationKeysArray, inputFuture);\n            \n            // Block until input is complete\n            Map<String, String> inputData = inputFuture.get(300, TimeUnit.SECONDS); // 5 minute timeout\n            \n            // Convert from UTF-8 to SJIS if needed\n            Map<String, String> sjisInputData = convertFromUtf8(inputData);\n            \n            // Update current field data\n            currentFieldData.putAll(sjisInputData);\n            \n            logger.info(\"Accept completed for WS-USER-SELECTION\");\n            return sjisInputData;\n            \n        } catch (TimeoutException e) {\n            logger.warn(\"Accept operation timed out for WS-USER-SELECTION\");\n            throw new RuntimeException(\"Input timeout\", e);\n        } catch (Exception e) {\n            logger.error(\"Error in accept method: \" + e.getMessage(), e);\n            throw new RuntimeException(\"Accept operation failed\", e);\n        }\n        \n    }\n\n    public void handleInteractiveProcess() {\n        try {\n            // Handle interactive DESTINATION processing\n            logger.info(\"Starting interactive processing\");\n            \n            // Setup bidirectional WebSocket communication\n            webSocketService.enableInteractiveMode(getCurrentTerminalId());\n            \n            // Process user interactions until completion\n            while (isInteractiveProcessingActive()) {\n                // Handle incoming WebSocket events\n                processWebSocketEvents();\n                \n                // Small delay to prevent busy waiting\n                Thread.sleep(100);\n            }\n            \n            logger.info(\"Interactive processing completed\");\n            \n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            logger.warn(\"Interactive processing interrupted\");\n        } catch (Exception e) {\n            logger.error(\"Error in interactive processing: \" + e.getMessage(), e);\n            throw new RuntimeException(\"Interactive processing failed\", e);\n        }\n        \n    }\n\n    public String[] convertToUtf8(String[] sjisData) {\n            try {\n                String[] utf8Data = new String[sjisData.length];\n                for (int i = 0; i < sjisData.length; i++) {\n                    if (sjisData[i] != null) {\n                        utf8Data[i] = encodingService.convertSjisToUtf8(sjisData[i]);\n                    } else {\n                        utf8Data[i] = \"\";\n                    }\n                }\n                return utf8Data;\n            } catch (Exception e) {\n                logger.error(\"UTF-8 conversion error: \" + e.getMessage(), e);\n                return sjisData; // Return original data on error\n            }\n            \n    }\n\n    public Map<String, String> convertFromUtf8(Map<String, String> utf8Data) {\n            try {\n                Map<String, String> sjisData = new HashMap<>();\n                for (Map.Entry<String, String> entry : utf8Data.entrySet()) {\n                    String convertedValue = encodingService.convertUtf8ToSjis(entry.getValue());\n                    sjisData.put(entry.getKey(), convertedValue);\n                }\n                return sjisData;\n            } catch (Exception e) {\n                logger.error(\"SJIS conversion error: \" + e.getMessage(), e);\n                return utf8Data; // Return original data on error\n            }\n            \n    }\n\n    // Helper methods\n    private String getCurrentTerminalId() {\n        // Get current terminal ID from session or context\n        return \"TERM001\"; // Default terminal ID\n    }\n    \n    private String getCurrentFieldValue(String fieldName) {\n        return currentFieldData.getOrDefault(fieldName, \"\");\n    }\n    \n    private boolean isInteractiveProcessingActive() {\n        // Check if interactive processing should continue\n        return webSocketService.isInteractiveMode(getCurrentTerminalId());\n    }\n    \n    private void processWebSocketEvents() {\n        // Process incoming WebSocket events\n        webSocketService.processIncomingEvents(getCurrentTerminalId());\n    }\n    \n    private void handlePositionUpdate(Map<String, Object> updateData) {\n        // Handle position-based field updates from WebSocket\n        @SuppressWarnings(\"unchecked\")\n        List<Map<String, Object>> updates = (List<Map<String, Object>>) updateData.get(\"updates\");\n        \n        for (Map<String, Object> update : updates) {\n            int row = (Integer) update.get(\"row\");\n            int col = (Integer) update.get(\"col\");\n            String value = (String) update.get(\"value\");\n            \n            // Find field by position and update value\n            updateFieldByPosition(row, col, value);\n        }\n    }\n    \n    private boolean handleKeyEvent(Map<String, Object> keyEvent, String[] terminationKeys) {\n        String key = (String) keyEvent.get(\"key\");\n        \n        // Check if it's a termination key\n        for (String termKey : terminationKeys) {\n            if (termKey.equals(key)) {\n                return true; // Terminate input\n            }\n        }\n        \n        return false; // Continue input\n    }\n    \n    private void setupTerminationKeys(String[] terminationKeys, \n                                    CompletableFuture<Map<String, String>> inputFuture) {\n        // Setup handlers for termination keys\n        for (String key : terminationKeys) {\n            webSocketService.onKeyEvent(getCurrentTerminalId(), key, () -> {\n                inputFuture.complete(getCurrentFieldData());\n            });\n        }\n    }\n    \n    private Map<String, String> getCurrentFieldData() {\n        return new HashMap<>(currentFieldData);\n    }\n    \n    private void updateFieldByPosition(int row, int col, String value) {\n        // Find field by position in MAP_DEFINITION\n        for (int i = 0; i < MAP_DEFINITION.length; i++) {\n            PositionField field = MAP_DEFINITION[i];\n            if (field.row == row && field.col == col) {\n                currentFieldData.put(\"field_\" + i, value);\n                break;\n            }\n        }\n    }\n}\n\n/**\n * Position field definition for SMED mapping\n */\nclass PositionField {\n    public final int row;\n    public final int col;\n    public final int length;\n    \n    public PositionField(int row, int col, int length) {\n        this.row = row;\n        this.col = col; \n        this.length = length;\n    }\n}\n",
  "map_json": "[\n  {\n    \"row\": 1,\n    \"col\": 1,\n    \"length\": 30\n  },\n  {\n    \"row\": 1,\n    \"col\": 33,\n    \"length\": 20\n  },\n  {\n    \"row\": 1,\n    \"col\": 55,\n    \"length\": 20\n  },\n  {\n    \"row\": 2,\n    \"col\": 1,\n    \"length\": 20\n  },\n  {\n    \"row\": 2,\n    \"col\": 23,\n    \"length\": 20\n  },\n  {\n    \"row\": 2,\n    \"col\": 45,\n    \"length\": 20\n  },\n  {\n    \"row\": 2,\n    \"col\": 67,\n    \"length\": 50\n  }\n]",
  "sample_data_json": "[\n  \"Sample1\",\n  \"Sample2\",\n  \"Sample3\",\n  \"Sample4\",\n  \"Sample5\",\n  \"Sample6\",\n  \"Sample7\"\n]",
  "position_fields_count": 7,
  "display_files_count": 4,
  "accept_files_count": 1,
  "conversion_timestamp": "2025-08-01T08:18:17.732724"
}